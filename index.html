<!doctype html>
<html lang="de">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Lead Extractor – Rohtext → CSV</title>
  <style>
    :root { color-scheme: light dark; }
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; margin: 16px; }
    h1 { font-size: 18px; margin: 0 0 10px; }
    .row { display: flex; gap: 10px; flex-wrap: wrap; align-items: center; margin: 10px 0; }
    .panel { border: 1px solid #8886; border-radius: 12px; padding: 10px; background: color-mix(in srgb, Canvas 92%, transparent); }
    textarea { width: 100%; min-height: 320px; resize: vertical; padding: 12px; border-radius: 12px; border: 1px solid #8886; background: color-mix(in srgb, Canvas 92%, transparent); }
    input[type="number"], select {
      padding: 8px; border-radius: 10px; border: 1px solid #8886;
      background: color-mix(in srgb, Canvas 92%, transparent);
    }
    button { padding: 10px 12px; border-radius: 10px; border: 1px solid #8886; cursor: pointer; background: color-mix(in srgb, Canvas 92%, transparent); }
    button:active { transform: translateY(1px); }
    button[disabled] { opacity: 0.5; cursor: not-allowed; }
    .small { font-size: 12px; opacity: 0.85; }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; }
    .stats { display: grid; grid-template-columns: repeat(auto-fit, minmax(210px, 1fr)); gap: 8px; margin-top: 10px; }
    .stat { padding: 10px; border-radius: 12px; border: 1px solid #8886; background: color-mix(in srgb, Canvas 92%, transparent); }
    .warn { color: #c00; }
    .ok { color: #0a7; }
    .errBox { display:none; margin-top:10px; border:1px solid #c006; border-radius:12px; padding:10px; background: color-mix(in srgb, Canvas 92%, transparent); }
    .errBox b { color:#c00; }

    .tableWrap { border: 1px solid #8886; border-radius: 12px; overflow: hidden; background: color-mix(in srgb, Canvas 92%, transparent); }
    .tableScroll { max-height: 320px; overflow: auto; }
    table { width: 100%; border-collapse: collapse; font-size: 12px; }
    thead th {
      position: sticky; top: 0;
      background: color-mix(in srgb, Canvas 96%, transparent);
      border-bottom: 1px solid #8886;
      padding: 10px 8px;
      text-align: left;
      white-space: nowrap;
      z-index: 2;
    }
    tbody td {
      border-bottom: 1px solid #8883;
      padding: 8px;
      vertical-align: top;
      white-space: nowrap;
      max-width: 260px;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    tbody tr:hover td { background: color-mix(in srgb, Canvas 88%, transparent); }

    .pill {
      display:inline-block; padding: 2px 8px; border: 1px solid #8886; border-radius: 999px;
      font-size: 12px; opacity: 0.9;
      background: color-mix(in srgb, Canvas 94%, transparent);
    }
    .right { margin-left: auto; }
  </style>
</head>
<body>
  <h1>Lead Extractor (Offline) – Rohtext → leads1.csv, leads2.csv, ...</h1>

  <div class="row small">
    <div class="panel" style="width:100%">
      <div><b>CSV Spalten:</b> <span class="mono">company_name,street,zip,city,phone,email,website,source,notes</span></div>
      <div class="small">Konservativ: Wenn unklar → Feld leer. Kein Raten. Keine Webrequests.</div>
    </div>
  </div>

  <textarea id="input" placeholder="Rohtext hier einfügen … (Maps / Impressum / Website / Müll gemischt)"></textarea>

  <div class="row">
    <label class="small">Max. Zeilen pro CSV:
      <input id="maxRows" type="number" min="1" step="1" value="5000" />
    </label>

    <label class="small">PLZ Export:
      <select id="zipMode">
        <option value="excel_text" selected>Excel-safe (01097 bleibt 01097)</option>
        <option value="plain">Plain (Excel kann führende 0 verlieren)</option>
      </select>
    </label>

    <button id="analyzeBtn">Analysieren</button>
    <button id="exportBtn" disabled>CSV exportieren</button>
    <button id="copyBtn" disabled>CSV kopieren</button>
    <button id="clearBtn" class="right">Leeren</button>
  </div>

  <div id="errBox" class="errBox">
    <div class="small"><b>Fehler:</b> <span id="errMsg" class="mono"></span></div>
  </div>

  <div class="stats" id="stats"></div>

  <div class="row">
    <div class="panel" style="width:100%">
      <div class="small"><b>Preview:</b> <span id="hint" class="small"></span></div>
      <div class="tableWrap" style="margin-top:8px;">
        <div class="tableScroll">
          <table id="previewTable">
            <thead><tr id="theadRow"></tr></thead>
            <tbody id="tbodyRows"></tbody>
          </table>
        </div>
      </div>
    </div>
  </div>

  <script>
    "use strict";

    const SOURCE_CONST = "manual_copy";
    const DEFAULT_NOTES_LIMIT = 120;
    const HEADER = ["company_name","street","zip","city","phone","email","website","source","notes"];

    const SOCIAL_HOST_BLACKLIST = [
      "facebook.com", "fb.com", "instagram.com", "linkedin.com", "tiktok.com",
      "youtube.com", "youtu.be", "xing.com", "twitter.com", "x.com", "pinterest.com"
    ];

    // Start-/Blockmarker (sehr wichtig für Segmentierung)
    const BLOCK_START_MARKERS = [
      /^google\s*maps$/i,
      /^apple\s*maps$/i,
      /^impressum$/i,
      /^kontakt$/i,
      /^contact$/i,
      /^anschrift\b/i,
      /^adresse\b/i
    ];

    // harte Trenner
    const HARD_SEPARATOR_LINE = /^(\-{3,}|={3,}|\*{3,}|•{3,}|_{3,})$/;

    const NOISE_PATTERNS = [
      /cookie(s)?/i, /consent/i, /datenschutz/i, /privacy/i,
      /\b(alle\s*rechte\s*vorbehalten|copyright|©)\b/i,
      /\b(navigation|menu|menü)\b/i,
      /\b(home|startseite|kontakt|leistungen|über uns|karriere|jobs|blog|news|shop|warenkorb)\b/i,
      /\b(standort(e)?|route|anfahrt)\b/i,
      /\b(google\s*analytics|matomo|tracking)\b/i,
      /\b(javascript|css|html)\b/i,
      /\b(accept|ablehnen|zustimmen|weiter)\b/i,
      /newsletter/i,
      /haftung/i, /urheber/i, /verantwortlich/i, /redaktionell/i
    ];

    const IMPRINT_HINTS = [
      /\bust-?id\b/i, /\bustid\b/i, /\bumsatzsteuer\b/i,
      /\bregistergericht\b/i, /\bhandelsregister\b/i,
      /\bhrb\b/i, /\bhra\b/i, /\bvertretungsberechtigt\b/i,
      /\bgeschäftsführer\b/i, /\binhaber\b/i
    ];

    function normalizeSpaces(s) {
      return (s || "")
        .replace(/\u00A0/g, " ")
        .replace(/[ \t]+/g, " ")
        .replace(/\s+\n/g, "\n")
        .replace(/\n{3,}/g, "\n\n")
        .trim();
    }
    function toLowerSafe(s) { return (s || "").toLowerCase(); }
    function clampNotes(s) {
      const t = (s || "").trim();
      if (t.length <= DEFAULT_NOTES_LIMIT) return t;
      return t.slice(0, DEFAULT_NOTES_LIMIT - 1).trim() + "…";
    }
    function stripLabels(s) {
      return (s || "")
        .replace(/^\s*(tel\.?|telefon|phone|mobil|fax)\s*[:\-]\s*/i, "")
        .replace(/^\s*(e-?mail)\s*[:\-]\s*/i, "")
        .replace(/^\s*(web(site)?|internet|url)\s*[:\-]\s*/i, "")
        .trim();
    }
    function normalizePhone(raw) {
      if (!raw) return "";
      let s = stripLabels(raw);
      s = s.replace(/[^\d +\/\-]/g, "");
      s = s.replace(/[ ]{2,}/g, " ").trim();
      return s;
    }
    function normalizeWebsite(raw) {
      if (!raw) return "";
      let s = stripLabels(raw).trim();
      s = s.replace(/^[\(\[\{<]+/, "").replace(/[\)\]\}>.,;!]+$/, "");
      s = s.replace(/(\?.*)$/, "");
      return s;
    }
    function getDomain(url) {
      if (!url) return "";
      let u = url.trim();
      u = u.replace(/^https?:\/\//i, "");
      u = u.replace(/^www\./i, "");
      u = u.split("/")[0];
      return u.toLowerCase();
    }
    function isSocialDomain(url) {
      const d = getDomain(url);
      if (!d) return false;
      return SOCIAL_HOST_BLACKLIST.some(host => d === host || d.endsWith("." + host));
    }

    function isProbablyNoiseLine(line) {
      const l = (line || "").trim();
      if (!l) return true;
      if (l.length <= 2) return true;
      if (/^[\-\–\—\•\|\/\\\s]+$/.test(l)) return true;

      // Cookie / legal boilerplate
      for (const re of NOISE_PATTERNS) {
        if (re.test(l) && l.length < 160) return true;
      }
      if (/(akzeptieren|zustimmen|ablehnen|einstellungen)/i.test(l) && /cookie/i.test(l)) return true;
      return false;
    }

    function findEmails(text) {
      const re = /\b[A-Z0-9._%+-]+@[A-Z0-9.-]+\.[A-Z]{2,}\b/gi;
      const found = (text || "").match(re) || [];
      return Array.from(new Set(found.map(e => e.toLowerCase())));
    }
    function findWebsites(text) {
      const t = text || "";
      const urls = new Set();

      const re1 = /\bhttps?:\/\/[^\s<>"')]+/gi;
      (t.match(re1) || []).forEach(u => urls.add(u));

      const re2 = /\bwww\.[^\s<>"')]+\b/gi;
      (t.match(re2) || []).forEach(u => urls.add(u));

      const re3 = /\b(?![A-Z0-9._%+-]+@)([a-z0-9-]+(?:\.[a-z0-9-]+)+)\b/gi;
      (t.match(re3) || []).forEach(d => {
        if (/\.(png|jpg|jpeg|gif|svg|pdf|css|js)$/i.test(d)) return;
        if (/(cookie|privacy|datenschutz|impressum)/i.test(d)) return;
        urls.add(d);
      });

      return Array.from(urls);
    }

    function findZipCity(text) {
      const re = /\b(\d{5})\s+([A-Za-zÀ-ÖØ-öø-ÿÄÖÜäöüß\.\- ]{2,})\b/g;
      let m;
      while ((m = re.exec(text)) !== null) {
        const zip = m[1];
        let city = (m[2] || "").trim();
        city = city.split("\n")[0].trim();
        city = city.replace(/\b(Tel|Telefon|Phone|E-Mail|Email|Web|Website|Bewertungen|Route)\b.*$/i, "").trim();
        if (city.length >= 2 && !/\d/.test(city)) return { zip, city };
      }
      return { zip: "", city: "" };
    }

    function findStreet(text) {
      const lines = (text || "").split(/\n/).map(l => l.trim()).filter(Boolean);
      const streetRe = /\b(straße|str\.|weg|platz|allee|gasse|ring|damm|ufer|promenade|chaussee|berg|hof|plan|markt)\b/i;
      const houseNoRe = /\b\d+[a-zA-Z]?\b/;

      for (const line of lines) {
        const l = line.trim();
        if (l.length < 6 || l.length > 140) continue;
        if (/,/.test(l) && streetRe.test(l) && houseNoRe.test(l)) {
          return l.split(",")[0].trim().replace(/^\s*(adresse|anschrift)\s*[:\-]\s*/i, "");
        }
        if (streetRe.test(l) && houseNoRe.test(l) && !/(register|ust|gericht|hrb|hra|steuer)/i.test(l)) {
          return l.replace(/^\s*(adresse|anschrift)\s*[:\-]\s*/i, "").trim();
        }
      }
      return "";
    }

    function findPhones(text) {
      const t = text || "";
      const candidates = new Set();

      const reLabel = /(?:tel\.?|telefon|phone|mobil|fax)\s*[:\-]?\s*([+\d][\d \-\/]{6,})/gi;
      let m;
      while ((m = reLabel.exec(t)) !== null) candidates.add(normalizePhone(m[1]));

      const reGeneral = /\b(?:\+49|0)\s*[\d][\d \-\/]{6,}\b/g;
      (t.match(reGeneral) || []).forEach(p => candidates.add(normalizePhone(p)));

      const arr = Array.from(candidates).filter(Boolean);
      arr.sort((a,b) => {
        const a49 = a.trim().startsWith("+49") ? 1 : 0;
        const b49 = b.trim().startsWith("+49") ? 1 : 0;
        if (a49 !== b49) return b49 - a49;
        return b.length - a.length;
      });
      return arr;
    }

    function isAddressLike(line) {
      const l = (line || "").trim();
      if (!l) return false;
      if (/\d{5}\s+\S+/.test(l)) return true;
      if (/(straße|str\.|weg|platz|allee|gasse)\b/i.test(l) && /\d/.test(l)) return true;
      return false;
    }
    function isContactLike(line) {
      const l = (line || "").trim();
      if (!l) return false;
      if (/@/.test(l)) return true;
      if (/(tel|telefon|phone|mobil|fax)\b/i.test(l)) return true;
      if (/\+49|(^|\s)0\d{2,}/.test(l)) return true;
      if (/https?:\/\//i.test(l) || /\bwww\./i.test(l)) return true;
      return false;
    }
    function looksLikeCompanyName(line) {
      const l = (line || "").trim();
      if (!l) return false;
      if (l.length < 2 || l.length > 140) return false;
      if (BLOCK_START_MARKERS.some(re => re.test(l))) return false;
      if (isAddressLike(l)) return false;
      if (isContactLike(l)) return false;
      if (isProbablyNoiseLine(l)) return false;
      if (/^(impressum|kontakt|datenschutz|privacy|agb|öffnungszeiten)$/i.test(l)) return false;
      return true;
    }

    // ✅ NEUER FIX: echte Segmentierung – zeilenbasiert
    function splitIntoBlocks(rawText) {
      const text = normalizeSpaces(rawText);
      if (!text) return [];

      const lines = text.split("\n").map(l => l.trim());

      const blocks = [];
      let cur = [];

      function pushBlock() {
        const b = cur.join("\n").trim();
        if (b) blocks.push(b);
        cur = [];
      }

      function blockHasCoreSignals(blockLines) {
        const t = blockLines.join("\n");
        return (
          /\b\d{5}\b/.test(t) ||
          /@/.test(t) ||
          /(tel|telefon|phone|mobil|fax)\b/i.test(t) ||
          /\+49|(^|\s)0\d{2,}/.test(t) ||
          /https?:\/\//i.test(t) ||
          /\bwww\./i.test(t)
        );
      }

      for (let i = 0; i < lines.length; i++) {
        const line = lines[i];

        // harte Trenner oder echte Leerzeile -> Block trennen
        if (!line) { pushBlock(); continue; }
        if (HARD_SEPARATOR_LINE.test(line)) { pushBlock(); continue; }

        // Startmarker -> neuer Block (aber Marker selbst bleibt im Block, damit Kontext da ist)
        if (BLOCK_START_MARKERS.some(re => re.test(line))) {
          // wenn bereits was drin ist: vorher abschließen
          if (cur.length) pushBlock();
          cur.push(line);
          continue;
        }

        // Heuristik: neue Firma beginnt, wenn Zeile wie Firmenname aussieht
        // UND der aktuelle Block bereits "Core" enthält (Adresse/Telefon/Web/Email etc.)
        if (looksLikeCompanyName(line) && cur.length && blockHasCoreSignals(cur)) {
          pushBlock();
        }

        cur.push(line);
      }
      pushBlock();

      // Optional: kleine Blocks zusammenfassen? Nein — lieber zu viele Blocks als zu wenige.
      return blocks;
    }

    function extractFromBlock(blockText) {
      const lines = (blockText || "")
        .split("\n")
        .map(l => l.trim())
        .filter(l => l.length > 0);

      const keptLines = [];
      let imprintHint = false;

      for (const line of lines) {
        if (IMPRINT_HINTS.some(re => re.test(line))) imprintHint = true;
        if (isProbablyNoiseLine(line)) continue;
        keptLines.push(line);
      }
      if (keptLines.length === 0) return null;

      const keptText = keptLines.join("\n");

      const emails = findEmails(keptText);
      const email = emails[0] || "";

      const websitesRaw = findWebsites(keptText)
        .map(normalizeWebsite)
        .filter(Boolean)
        .filter(u => !isSocialDomain(u));

      let website = "";
      if (websitesRaw.length) {
        website = websitesRaw[0];
      }

      const phones = findPhones(keptText);
      const phone = phones[0] || "";

      const { zip, city } = findZipCity(keptText);
      const street = findStreet(keptText);

      let company_name = "";
      for (const line of keptLines) {
        if (looksLikeCompanyName(line)) { company_name = line; break; }
      }

      // Wenn KEIN Firmenname erkannt, aber es gibt klare Kontaktsignale:
      // -> trotzdem Datensatz erzeugen (company_name leer), damit du ihn später manuell füllen kannst.
      const hasAnyCore = Boolean(company_name || phone || email || website || (zip && city) || street);
      if (!hasAnyCore) return null;

      const notes = [];
      if (imprintHint) notes.push("Impressum gefunden");
      if (!company_name) notes.push("Name unklar");
      if (!email) notes.push("keine Email");
      if (!street && !(zip && city)) notes.push("Adresse unklar");
      if (phones.length > 1) notes.push("mehrere Nummern");
      if (emails.length > 1) notes.push("mehrere Emails");
      if (website && websitesRaw.length > 1) notes.push("mehrere Websites");

      return {
        company_name: company_name || "",
        street: street || "",
        zip: zip || "",
        city: city || "",
        phone: phone || "",
        email: email || "",
        website: website || "",
        source: SOURCE_CONST,
        notes: clampNotes(notes.join(", "))
      };
    }

    function normalizeKeyPart(s) {
      return toLowerSafe((s || ""))
        .replace(/[^a-z0-9äöüß]+/gi, " ")
        .replace(/\s+/g, " ")
        .trim();
    }
    function recordKey(rec) {
      const name = normalizeKeyPart(rec.company_name);
      const zc = normalizeKeyPart((rec.zip || "") + " " + (rec.city || ""));
      const dom = normalizeKeyPart(getDomain(rec.website));
      const phone = normalizeKeyPart(rec.phone);
      if (dom) return "d:" + dom;
      if (phone) return "p:" + phone;
      if (name && zc) return "nzc:" + name + "|" + zc;
      if (name) return "n:" + name;
      return "u:" + Math.random().toString(36).slice(2);
    }
    function mergeRecords(base, incoming) {
      const out = { ...base };
      for (const k of HEADER) {
        if (k === "notes") continue;
        if (!out[k] && incoming[k]) out[k] = incoming[k];
      }
      const notes = new Set();
      [base.notes, incoming.notes].forEach(n => {
        (n || "").split(",").map(x => x.trim()).filter(Boolean).forEach(x => notes.add(x));
      });
      notes.add("merged");
      out.notes = clampNotes(Array.from(notes).join(", "));
      return out;
    }
    function dedupe(records) {
      const map = new Map();
      const kept = [];
      for (const r of records) {
        const key = recordKey(r);
        if (!map.has(key)) {
          map.set(key, r);
          kept.push(r);
        } else {
          const merged = mergeRecords(map.get(key), r);
          map.set(key, merged);
          const idx = kept.indexOf(map.get(key));
          if (idx >= 0) kept[idx] = merged;
        }
      }
      // Fix for kept list update (above line was wrong with map.get(key) after set)
      // We'll rebuild array from map:
      return Array.from(map.values());
    }

    function completenessScore(r) {
      let s = 0;
      ["company_name","street","zip","city","phone","email","website"].forEach(k => { if (r[k]) s += 1; });
      return s;
    }

    function parseAll(rawText) {
      const blocks = splitIntoBlocks(rawText);
      const extracted = [];
      let skipped = 0;

      for (const b of blocks) {
        const rec = extractFromBlock(b);
        if (rec) extracted.push(rec);
        else skipped++;
      }

      const deduped = dedupe(extracted);
      deduped.sort((a,b) => completenessScore(b) - completenessScore(a));

      return { blocksCount: blocks.length, extractedCount: extracted.length, dedupedCount: deduped.length, skippedCount: skipped, records: deduped };
    }

    function csvEscape(val) {
      const s = (val ?? "").toString();
      if (/[",\n]/.test(s)) return '"' + s.replace(/"/g, '""') + '"';
      return s;
    }
    function formatZipForCSV(zip, mode) {
      const z = (zip || "").trim();
      if (!z) return "";
      if (mode === "excel_text") return "'" + z;
      return z;
    }
    function recordsToCSV(records, zipMode) {
      const lines = [HEADER.join(",")];
      for (const r of records) {
        const row = HEADER.map(h => {
          if (h === "zip") return csvEscape(formatZipForCSV(r.zip || "", zipMode));
          return csvEscape(r[h] || "");
        });
        lines.push(row.join(","));
      }
      return lines.join("\n");
    }
    function downloadText(filename, content) {
      const blob = new Blob([content], { type: "text/csv;charset=utf-8" });
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = filename;
      document.body.appendChild(a);
      a.click();
      a.remove();
      setTimeout(() => URL.revokeObjectURL(url), 1000);
    }
    function exportBatches(records, maxRowsPerFile, zipMode) {
      const maxRows = Math.max(1, parseInt(maxRowsPerFile, 10) || 500);
      let fileNo = 1;
      for (let i = 0; i < records.length; i += maxRows) {
        const chunk = records.slice(i, i + maxRows);
        const csv = recordsToCSV(chunk, zipMode);
        downloadText(`leads${fileNo}.csv`, csv);
        fileNo++;
      }
    }
    async function copyToClipboard(text) {
      if (navigator.clipboard && navigator.clipboard.writeText) {
        await navigator.clipboard.writeText(text);
        return true;
      }
      const ta = document.createElement("textarea");
      ta.value = text;
      document.body.appendChild(ta);
      ta.select();
      const ok = document.execCommand("copy");
      ta.remove();
      return ok;
    }

    // --- UI ---
    const inputEl = document.getElementById("input");
    const maxRowsEl = document.getElementById("maxRows");
    const zipModeEl = document.getElementById("zipMode");
    const analyzeBtn = document.getElementById("analyzeBtn");
    const exportBtn = document.getElementById("exportBtn");
    const copyBtn = document.getElementById("copyBtn");
    const clearBtn = document.getElementById("clearBtn");
    const statsEl = document.getElementById("stats");
    const hintEl = document.getElementById("hint");
    const theadRow = document.getElementById("theadRow");
    const tbodyRows = document.getElementById("tbodyRows");
    const errBox = document.getElementById("errBox");
    const errMsg = document.getElementById("errMsg");

    let lastResult = null;

    function showError(e) {
      errMsg.textContent = (e && e.message) ? e.message : String(e);
      errBox.style.display = "block";
    }
    function clearError() {
      errMsg.textContent = "";
      errBox.style.display = "none";
    }

    function renderStats(res) {
      const cards = [
        { label: "Blöcke erkannt", value: res.blocksCount },
        { label: "Extrahiert (vor Dedupe)", value: res.extractedCount },
        { label: "Nach Dedupe/Merge", value: res.dedupedCount },
        { label: "Übersprungen (nur Müll/unklar)", value: res.skippedCount },
      ];
      statsEl.innerHTML = cards.map(c => `
        <div class="stat">
          <div class="small">${c.label}</div>
          <div style="font-size:18px"><b>${c.value}</b></div>
        </div>
      `).join("");
    }

    function renderTable(records) {
      theadRow.innerHTML = HEADER.map(h => `<th>${h}</th>`).join("");
      const previewN = Math.min(50, records.length);
      const zipMode = zipModeEl.value;
      tbodyRows.innerHTML = "";

      for (let i = 0; i < previewN; i++) {
        const r = records[i];
        const cells = HEADER.map(h => {
          let v = r[h] || "";
          if (h === "zip") v = formatZipForCSV(v, zipMode);
          const title = String(v).replace(/"/g,'&quot;');
          return `<td title="${title}">${String(v)}</td>`;
        }).join("");
        tbodyRows.innerHTML += `<tr>${cells}</tr>`;
      }
    }

    function updateHint(recordsCount) {
      const zipMode = zipModeEl.value === "excel_text"
        ? `<span class="pill">PLZ: Excel-safe</span>`
        : `<span class="pill">PLZ: Plain</span>`;
      hintEl.innerHTML = recordsCount
        ? `<span class="ok">OK</span> – ${recordsCount} Datensätze. ${zipMode} <span class="small">Preview max. 50 Zeilen.</span>`
        : `<span class="warn">Keine Datensätze.</span> <span class="small">Tipp: Kopierte Firmen müssen nicht doppelt getrennt sein – Parser erkennt Startmarker.</span>`;
    }

    analyzeBtn.addEventListener("click", () => {
      try {
        clearError();
        lastResult = parseAll(inputEl.value || "");
        renderStats(lastResult);
        renderTable(lastResult.records);
        updateHint(lastResult.records.length);
        exportBtn.disabled = !(lastResult.records && lastResult.records.length);
        copyBtn.disabled = !(lastResult.records && lastResult.records.length);
      } catch (e) { showError(e); }
    });

    exportBtn.addEventListener("click", () => {
      try {
        clearError();
        if (!lastResult || !lastResult.records || !lastResult.records.length) return;
        exportBatches(lastResult.records, maxRowsEl.value, zipModeEl.value);
      } catch (e) { showError(e); }
    });

    copyBtn.addEventListener("click", async () => {
      try {
        clearError();
        if (!lastResult || !lastResult.records || !lastResult.records.length) return;
        const csv = recordsToCSV(lastResult.records, zipModeEl.value);
        const ok = await copyToClipboard(csv);
        hintEl.innerHTML = ok ? `<span class="ok">CSV kopiert.</span>` : `<span class="warn">Kopieren nicht möglich – nutze Export.</span>`;
      } catch (e) { showError(e); }
    });

    clearBtn.addEventListener("click", () => {
      clearError();
      inputEl.value = "";
      statsEl.innerHTML = "";
      theadRow.innerHTML = "";
      tbodyRows.innerHTML = "";
      hintEl.innerHTML = "";
      exportBtn.disabled = true;
      copyBtn.disabled = true;
      lastResult = null;
    });

    zipModeEl.addEventListener("change", () => {
      if (!lastResult) return;
      renderTable(lastResult.records);
    });
  </script>
</body>
</html>
